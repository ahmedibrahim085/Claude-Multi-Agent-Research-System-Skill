# Session State Schema Documentation

**Purpose:** Document the session state management system for first-prompt reindex architecture
**Last Updated:** 2025-12-12
**Schema Version:** 1.0

---

## Overview

The session state system tracks whether the first-prompt background reindex has been triggered for the current session. This prevents duplicate reindex triggers and enables once-per-session behavior.

**Key Concept:** Session boundaries are defined by `session_id` changes, not by `source` parameter from Claude Code.

---

## State File Location

**Path:** `logs/state/session-reindex-tracking.json`

**Relative to:** Project root directory

**Created by:** `initialize_session_state()` called by session-start hook

**Updated by:**
- `initialize_session_state()` - Reset on new session
- `mark_first_prompt_shown()` - Set flag after first-prompt triggers

---

## Schema Definition

### Version 1.0 (Current)

```json
{
  "session_id": "session_YYYYMMDD_HHMMSS",
  "first_semantic_search_shown": boolean
}
```

### Field Descriptions

#### `session_id` (string, required)

**Format:** `session_YYYYMMDD_HHMMSS`

**Example:** `session_20251212_154827`

**Purpose:** Unique identifier for current Claude Code session

**Generated by:** `session_logger.get_session_id()`

**Lifecycle:**
- Created: When Claude Code starts
- Changes: Every restart (even with `source='resume'`)
- Persists: Until next restart

**Critical:** This is the **authoritative signal** for "new session". When this changes, the flag MUST reset to `false`.

#### `first_semantic_search_shown` (boolean, required)

**Purpose:** Tracks whether first-prompt reindex has been triggered this session

**Values:**
- `false` - First-prompt has NOT triggered yet (ready to trigger)
- `true` - First-prompt has already triggered (skip on subsequent prompts)

**Lifecycle:**
- Set to `false`: When session_id changes (new session)
- Set to `true`: After first-prompt spawns background reindex
- Reset: On next session_id change

**Used by:**
- `should_show_first_prompt_status()` - Returns `not value`
- `mark_first_prompt_shown()` - Sets to `true`

---

## State Transitions

### Startup Flow

```
1. Claude Code starts
   ↓
2. SessionStart hook fires
   ↓
3. initialize_session_state(source='startup')
   ↓
4. Check: Does state file exist?
   ├─ No  → Create new: {session_id: new, first_semantic_search_shown: false}
   └─ Yes → Load and check session_id
              ├─ session_id changed → Reset: {session_id: new, first_semantic_search_shown: false}
              └─ session_id same    → Preserve (shouldn't happen on startup)
   ↓
5. User types first prompt
   ↓
6. UserPromptSubmit hooks fire (parallel):
   - first-prompt-reindex.py
   - user-prompt-submit.py (skill enforcement)
   ↓
7. first-prompt-reindex.py:
   - Checks: should_show_first_prompt_status() → Returns true (flag is false)
   - Spawns background reindex
   - Calls: mark_first_prompt_shown() → Sets flag to true
   ↓
8. User types second prompt
   ↓
9. first-prompt-reindex.py:
   - Checks: should_show_first_prompt_status() → Returns false (flag is true)
   - Exits immediately (no work)
```

### Restart Flow

```
1. Claude Code restarts (user closed and reopened)
   ↓
2. SessionStart hook fires with source='resume'
   ↓
3. initialize_session_state(source='resume')
   ↓
4. Load existing state: {session_id: old, first_semantic_search_shown: true}
   ↓
5. Get current session_id: session_20251212_163000 (NEW!)
   ↓
6. Check: old != current → NEW SESSION
   ↓
7. Reset state: {session_id: new, first_semantic_search_shown: false}
   ↓
8. Write to file
   ↓
9. First prompt triggers background reindex (flow same as Startup)
```

### Compaction Flow (Future - if Claude Code implements)

```
1. Context reaches limit
   ↓
2. Claude Code compacts context
   ↓
3. SessionStart hook fires with source='compact'
   ↓
4. initialize_session_state(source='compact')
   ↓
5. Load state: {session_id: old, first_semantic_search_shown: true}
   ↓
6. Get current session_id: SAME as before (hypothetical - not tested)
   ↓
7. Check: old == current → SAME SESSION
   ↓
8. Preserve state: {session_id: same, first_semantic_search_shown: true}
   ↓
9. First prompt does NOT trigger reindex (already happened this session)
```

**Note:** As of 2025-12-12, Claude Code always changes session_id on every restart, even with `source='resume'`. The compaction flow is theoretical.

---

## API Reference

### Functions

#### `initialize_session_state(source: str = 'unknown') -> None`

**Location:** `.claude/utils/reindex_manager.py:1767-1831`

**Purpose:** Initialize or reset session state for new session

**Parameters:**
- `source`: SessionStart source parameter (`'startup'`, `'clear'`, `'resume'`, `'unknown'`)
  - **Not used for decision** - Only logged for debugging
  - **session_id change is the authoritative signal**

**Behavior:**
```python
if session_id changed:
    # ALWAYS reset, regardless of source
    state["session_id"] = new_session_id
    state["first_semantic_search_shown"] = False
else:
    # Same session (shouldn't happen, but preserve if it does)
    # Keep existing flag value
```

**Error Handling:**
- Never raises exceptions
- Logs errors to stderr
- Safe default: Creates new state if any error

#### `should_show_first_prompt_status() -> bool`

**Location:** `.claude/utils/reindex_manager.py:1963-1993`

**Purpose:** Check if this is the first prompt of the session

**Returns:**
- `True` - First prompt (trigger reindex)
- `False` - Not first prompt (skip)

**Logic:**
```python
if file_missing:
    return True  # Safe default: trigger
if json_error:
    return True  # Safe default: trigger
return not state.get("first_semantic_search_shown", False)
```

**Used by:**
- `first-prompt-reindex.py` - Decides whether to spawn background reindex
- `user-prompt-submit.py` - Decides whether to show reindex status (secondary check)

#### `mark_first_prompt_shown() -> None`

**Location:** `.claude/utils/reindex_manager.py:1996-2010`

**Purpose:** Mark that first-prompt has been triggered (don't trigger again)

**Behavior:**
```python
state["first_semantic_search_shown"] = True
state_file.write_text(json.dumps(state, indent=2))
```

**Error Handling:**
- Never raises exceptions
- Logs errors to stderr
- Safe: If marking fails, worst case is duplicate trigger (claim file prevents duplicates anyway)

**Called by:**
- `first-prompt-reindex.py` - After spawning background reindex

---

## Edge Cases

### 1. State File Missing

**Scenario:** File deleted or never created

**Behavior:**
- `should_show_first_prompt_status()` returns `True`
- First-prompt triggers background reindex
- `mark_first_prompt_shown()` creates new file

**Outcome:** ✅ Correct - reindex triggers as if fresh session

### 2. State File Corrupted (Invalid JSON)

**Scenario:** File contains malformed JSON

**Behavior:**
- `should_show_first_prompt_status()` catches `json.JSONDecodeError`
- Returns `True` (safe default)
- First-prompt triggers background reindex
- `mark_first_prompt_shown()` overwrites with valid JSON

**Outcome:** ✅ Correct - recovery via overwrite

### 3. Missing `session_id` Field

**Scenario:** Old schema version without session_id

**Behavior:**
- `state.get("session_id")` returns `None`
- `old_session_id != session_id` evaluates to `True`
- Treated as new session
- Flag resets to `false`

**Outcome:** ✅ Correct - treats as new session

### 4. Missing `first_semantic_search_shown` Field

**Scenario:** State has session_id but missing flag

**Behavior:**
- `state.get("first_semantic_search_shown", False)` returns `False`
- `should_show_first_prompt_status()` returns `True`
- First-prompt triggers

**Outcome:** ✅ Correct - safe default

### 5. Flag Stuck at `true` After Restart

**Scenario:** Bug - session_id changed but flag wasn't reset

**Behavior (BEFORE fix):**
- First-prompt checks flag → `true`
- Skips reindex
- User never gets automatic reindex

**Outcome (BEFORE):** ❌ BUG - This was the critical session-ID bug

**Behavior (AFTER fix):**
- `initialize_session_state()` always resets when session_id changes
- Flag guaranteed to be `false` on new sessions
- First-prompt triggers correctly

**Outcome (AFTER):** ✅ FIXED

---

## Schema Evolution

### Future Versions

**If schema needs to change:**

1. **Add version field** (required for v2.0):
```json
{
  "version": 2,
  "session_id": "session_20251212_154827",
  "first_semantic_search_shown": true,
  "new_field": "value"
}
```

2. **Migration strategy:**
```python
def migrate_session_state(state: dict) -> dict:
    version = state.get("version", 1)

    if version == 1:
        # v1 → v2: Add version field
        state["version"] = 2
        # Add new fields with defaults
        state["new_field"] = default_value

    return state
```

3. **Backward compatibility:**
   - Read both old and new schemas
   - Write only new schema
   - Graceful degradation if unknown version

### Deprecation Policy

**Before removing fields:**
1. Mark as deprecated in docs (1 release)
2. Stop writing field (1 release)
3. Remove reading code (1 release)

**Total:** 3 releases minimum before complete removal

---

## Validation

### Schema Validation (Future Enhancement)

**Not currently implemented**, but recommended:

```python
import jsonschema

SESSION_STATE_SCHEMA = {
    "type": "object",
    "required": ["session_id", "first_semantic_search_shown"],
    "properties": {
        "session_id": {
            "type": "string",
            "pattern": "^session_[0-9]{8}_[0-9]{6}$"
        },
        "first_semantic_search_shown": {
            "type": "boolean"
        }
    },
    "additionalProperties": False
}

def validate_session_state(state: dict) -> bool:
    try:
        jsonschema.validate(state, SESSION_STATE_SCHEMA)
        return True
    except jsonschema.ValidationError:
        return False
```

---

## Testing

### Unit Tests

**Test file:** `tests/test_session_state.py` (recommended, not yet implemented)

**Test cases needed:**
1. ✅ Initialize fresh session
2. ✅ Reset on session_id change
3. ✅ Preserve on same session_id
4. ✅ Handle missing file
5. ✅ Handle corrupted JSON
6. ✅ Handle missing fields
7. ⚠️ Handle concurrent writes (race condition)

### Integration Tests

**Scenarios:**
1. ✅ Restart Claude Code → First-prompt triggers
2. ✅ Multiple prompts same session → First-prompt only triggers once
3. ⚠️ Compaction → First-prompt doesn't re-trigger (not testable yet)

---

## Debugging

### View Current State

```bash
cat logs/state/session-reindex-tracking.json | python3 -m json.tool
```

### Check Session ID Match

```bash
python3 <<'EOF'
import json, sys
from pathlib import Path
sys.path.insert(0, '.claude/utils')
import session_logger

state_file = Path('logs/state/session-reindex-tracking.json')
if state_file.exists():
    state = json.loads(state_file.read_text())
    current = session_logger.get_session_id()
    print(f'State file session:  {state.get("session_id")}')
    print(f'Current session:     {current}')
    print(f'Sessions match:      {state.get("session_id") == current}')
    print(f'Flag value:          {state.get("first_semantic_search_shown")}')
else:
    print('No state file')
EOF
```

### Simulate First-Prompt

```bash
# Reset flag
python3 <<'EOF'
import json, sys
from pathlib import Path
sys.path.insert(0, '.claude/utils')
import session_logger

state_file = Path('logs/state/session-reindex-tracking.json')
state = json.loads(state_file.read_text()) if state_file.exists() else {}
state["session_id"] = session_logger.get_session_id()
state["first_semantic_search_shown"] = False
state_file.write_text(json.dumps(state, indent=2))
print("Flag reset to false")
EOF

# Check if first-prompt would trigger
python3 -c "
import sys
from pathlib import Path
sys.path.insert(0, '.claude/utils')
import reindex_manager
print(f'Would trigger: {reindex_manager.should_show_first_prompt_status()}')
"
```

---

## Related Documentation

- **Recovery Procedures:** `docs/operations/RECOVERY-PROCEDURES.md` - Fix corrupted state
- **Architecture Review:** `docs/architecture/HONEST-ARCHITECTURE-REVIEW-20251212.md` - Design analysis
- **Bug Fix:** `docs/fixes/session-id-change-bug-fix.md` - Critical fix details

---

**Schema Version:** 1.0
**Last Updated:** 2025-12-12
**Status:** Production
