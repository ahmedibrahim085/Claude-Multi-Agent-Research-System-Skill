#!/usr/bin/env bash
# Find similar chunks using FixedCodeIndexManager with IndexFlatIP (MCP's proven approach)

VENV_PYTHON="$HOME/.local/share/claude-context-local/.venv/bin/python"
export PYTHONPATH="$HOME/.local/share/claude-context-local"

# Get script directory for importing our module
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# CRITICAL FIX: Resolve project path to absolute BEFORE cd
# Rebuild args with absolute project path
RESOLVED_ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --project)
            if [[ -n "$2" ]]; then
                # Resolve to absolute path before cd
                RESOLVED_ARGS+=("--project" "$(cd "$2" && pwd)")
                shift 2
            else
                shift
            fi
            ;;
        *)
            RESOLVED_ARGS+=("$1")
            shift
            ;;
    esac
done

cd "$HOME/.local/share/claude-context-local"

# Call our find_similar implementation with IndexFlatIP (simple, reliable)
"$VENV_PYTHON" -c "
# CRITICAL: Force CPU mode BEFORE any imports to avoid MPS+FAISS segfault
import os
os.environ['TOKENIZERS_PARALLELISM'] = 'false'
os.environ['PYTORCH_ENABLE_MPS_FALLBACK'] = '0'
os.environ['CUDA_VISIBLE_DEVICES'] = ''

import sys
import json
sys.path.insert(0, '$SCRIPT_DIR')

# Force PyTorch to CPU before any model loading
import torch
torch.set_default_device('cpu')

from incremental_reindex import FixedCodeIndexManager

# Parse arguments
chunk_id = None
k = 5
project_path = None

i = 1
while i < len(sys.argv):
    if sys.argv[i] == '--chunk-id':
        chunk_id = sys.argv[i+1]
        i += 2
    elif sys.argv[i] == '--k':
        k = int(sys.argv[i+1])
        i += 2
    elif sys.argv[i] == '--project':
        project_path = sys.argv[i+1]
        i += 2
    else:
        i += 1

if not chunk_id:
    print('Usage: find-similar --chunk-id \"chunk_id\" [--k NUM] [--project PATH]', file=sys.stderr)
    sys.exit(1)

if not project_path:
    print('Error: --project is required', file=sys.stderr)
    sys.exit(1)

try:
    # Load index manager with IndexFlatIP (sequential IDs)
    index_manager = FixedCodeIndexManager(project_path)

    # Find similar chunks (uses chunk_ids list for IndexFlatIP)
    results = index_manager.find_similar(chunk_id, k=k)

    # Format results (compatible with expected output format)
    formatted_results = []
    for similar_chunk_id, score, metadata in results:
        formatted_results.append({
            'file': metadata.get('file_path') or metadata.get('relative_path', 'unknown'),
            'lines': f\"{metadata.get('start_line', '?')}-{metadata.get('end_line', '?')}\",
            'kind': metadata.get('type', 'unknown'),
            'score': round(score, 2),
            'chunk_id': similar_chunk_id,
            'name': metadata.get('name', ''),
            'snippet': metadata.get('content', '')[:200] if metadata.get('content') else ''
        })

    output = {
        'chunk_id': chunk_id,
        'results': formatted_results
    }

    print(json.dumps(output, indent=2))

except Exception as e:
    print(json.dumps({
        'chunk_id': chunk_id,
        'results': [],
        'error': str(e)
    }, indent=2), file=sys.stderr)
    sys.exit(1)
" "${RESOLVED_ARGS[@]}"
